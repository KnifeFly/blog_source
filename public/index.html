<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="KnifeFly">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="KnifeFly">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KnifeFly">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>KnifeFly</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KnifeFly</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/25/ClickHouse压缩与解压/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KnifeFly">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/25/ClickHouse压缩与解压/" itemprop="url">ClickHouse 数据压缩与解压</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-25T12:43:29+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ClickHouse-数据压缩与解压"><a href="#ClickHouse-数据压缩与解压" class="headerlink" title="ClickHouse 数据压缩与解压"></a>ClickHouse 数据压缩与解压</h1><p>ClickHouse 是一款真正面向列的DBMS，就是一款列式数据库，所以ClickHouse非常适合作为OLAP的数据查询引擎。通常列式数据库具有非常好的数据压缩效果，因为每列数据的数据类型一致，保存时会作为一个数组数据挨着保存，这样压缩算法具有非常好的压缩效果，在OLAP查询场景下可以有效的提高整个系统的吞吐量。</p>
<p>ClickHouse目前支持的数据压缩算法是lz4和zstd，其中zstd是实验性，默认情况下ClickHouse采用的是lz4压缩算法。压缩的主要配置项示例如下，通常情况下不会去更改这几个配置项，因为默认配置就可以让数据压缩效率非常高。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">compression</span> <span class="attr">incl</span>=<span class="string">"clickhouse_compression"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">min_part_size</span>&gt;</span>10000000000<span class="tag">&lt;/<span class="name">min_part_size</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">min_part_size_ratio</span>&gt;</span>0.01<span class="tag">&lt;/<span class="name">min_part_size_ratio</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">method</span>&gt;</span>zstd<span class="tag">&lt;/<span class="name">method</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">compression</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于压缩算法的测试，见<a href="https://link.zhihu.com/?target=https%3A//www.percona.com/blog/2016/04/13/evaluating-database-compression-methods-update/" target="_blank" rel="noopener">这篇文章</a>。简而言之，LZ4在速度上会更快，但是压缩率较低，ZSTD正好相反。尽管ZSTD比LZ4慢，但是相比传统的压缩方式Zlib，无论是在压缩效率还是速度上，都可以作为Zlib的替代品。</p>
<h2 id="压缩比"><a href="#压缩比" class="headerlink" title="压缩比"></a>压缩比</h2><p>官方有提供星型模块基准测试的案例，<a href="https://www.altinity.com/blog/2017/6/16/clickhouse-in-a-general-analytical-workload-based-on-star-schema-benchmark" target="_blank" rel="noopener">clickhouse-in-a-general-analytical-workload-based-on-star-schema-benchmark</a>  该基准测试案例lineorder数据表字段基本都是整形，该表lineorder原始数据有150亿条记录，原始数据总大小为1.7TB，导入到ClickHouse后lineorder数据表占用464GB，压缩比达到了3.7倍数。</p>
<p>目前我们的ClickHouse数据库中存储一些nginx原始日志信息raw_cdn_nginx_log_all，nginx原始访问日志以及维度扩展之后的日志数据每行大概会有100左右个字段信息，我们截取其中40多个有助于OLAP查询高频字段，数据表字段信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">    timeStamp DateTime,</span><br><span class="line">    date Date,</span><br><span class="line">    province String,</span><br><span class="line">    isp String,</span><br><span class="line">    upstream_addr String,</span><br><span class="line">    hostname String,</span><br><span class="line">    machineIP String,</span><br><span class="line">    country String,</span><br><span class="line">    scheme String,</span><br><span class="line">    upstream_local_port String,</span><br><span class="line">    channel String,</span><br><span class="line">    node String,</span><br><span class="line">    cacheGroup String,</span><br><span class="line">    city String,</span><br><span class="line">    view String,</span><br><span class="line">    status String,</span><br><span class="line">    customer String,</span><br><span class="line">    nodeisp String,</span><br><span class="line">    app String,</span><br><span class="line">    http_host String,</span><br><span class="line">    upstream_status String,</span><br><span class="line">    deviceID String,</span><br><span class="line">    remote_addr String,</span><br><span class="line">    request_id String,</span><br><span class="line">    serviceGroupId String,</span><br><span class="line">    request String,</span><br><span class="line">    http_referer String,</span><br><span class="line">    serverType String,</span><br><span class="line">    conn_state String,</span><br><span class="line">    upstream_keepalive String,</span><br><span class="line">    http_user_agent String,</span><br><span class="line">    body_bytes_sent Int64,</span><br><span class="line">    client_rtt Float32,</span><br><span class="line">    ssl_handshake_time Float32,</span><br><span class="line">    response_time Float32,</span><br><span class="line">    first_byte_time Float32,</span><br><span class="line">    upstream_response_time String,</span><br><span class="line">    bytes_sent Int64,</span><br><span class="line">    download_time Float32,</span><br><span class="line">    half_rtt_time Float32,</span><br><span class="line">    request_time Float32</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>ClickHouse集群有4台机器，2019-06-14这一天集群的数据记录条数是2.4亿，那时候还不算业务爆发期，这2.4亿条的数据在clickhouse集群中总占用大小在12G左右，每台机器占用空间大小为3G左右。</p>
<p><img src="/images/image-20190825110851852.png" alt="sd"></p>
<p>每行原始数据信息大概如下，每条JSON格式的数据记录大概是1000字节左右，2.4亿条JSON格式的输入数据大小为240G左右。如果是以CSV格式存储，则单条记录大小大概是380字节，2.4亿条CSV格式的输入数据大小为93G。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"timeStamp"</span>:<span class="string">"2019-06-14 02:37:31"</span>,<span class="attr">"date"</span>:<span class="string">"2019-06-14"</span>,<span class="attr">"province"</span>:<span class="string">"GZ"</span>,<span class="attr">"isp"</span>:<span class="string">"CM"</span>,<span class="attr">"upstream_addr"</span>:<span class="string">""</span>,<span class="attr">"hostname"</span>:<span class="string">"SR-CNCM-GZKWE-38-23"</span>,<span class="attr">"machineIP"</span>:<span class="string">"xxx"</span>,<span class="attr">"country"</span>:<span class="string">"CN"</span>,<span class="attr">"scheme"</span>:<span class="string">"https"</span>,<span class="attr">"upstream_local_port"</span>:<span class="string">""</span>,<span class="attr">"channel"</span>:<span class="string">"xxx"</span>,<span class="attr">"node"</span>:<span class="string">"IDC-CNCM-GZKWE-Dnion"</span>,<span class="attr">"cacheGroup"</span>:<span class="string">"SG-CNCM-GZKWE-cacheOpt-01"</span>,<span class="attr">"city"</span>:<span class="string">"KWE"</span>,<span class="attr">"view"</span>:<span class="string">"CN_CM_XN_GZ"</span>,<span class="attr">"status"</span>:<span class="string">"200"</span>,<span class="attr">"customer"</span>:<span class="string">"meitu"</span>,<span class="attr">"nodeisp"</span>:<span class="string">"CM"</span>,<span class="attr">"app"</span>:<span class="string">"APP-WEB"</span>,<span class="attr">"http_host"</span>:<span class="string">"api.meipai.com"</span>,<span class="attr">"upstream_status"</span>:<span class="string">"200"</span>,<span class="attr">"deviceID"</span>:<span class="string">"9233d8bbfe37eed97679b6f768858d06"</span>,<span class="attr">"remote_addr"</span>:<span class="string">"223.104.96.19"</span>,<span class="attr">"request_id"</span>:<span class="string">"31f80ef11dc338493cf25c5334dcbfc8"</span>,<span class="attr">"serviceGroupId"</span>:<span class="string">"1152"</span>,<span class="attr">"request"</span>:<span class="string">""</span>,<span class="attr">"http_referer"</span>:<span class="string">""</span>,<span class="attr">"serverType"</span>:<span class="string">"0"</span>,<span class="attr">"conn_state"</span>:<span class="string">""</span>,<span class="attr">"upstream_keepalive"</span>:<span class="string">"1"</span>,<span class="attr">"http_user_agent"</span>:<span class="string">""</span>,<span class="attr">"body_bytes_sent"</span>:<span class="string">"8069"</span>,<span class="attr">"client_rtt"</span>:<span class="number">0.029</span>,<span class="attr">"ssl_handshake_time"</span>:<span class="number">0</span>,<span class="attr">"response_time"</span>:<span class="number">0.259</span>,<span class="attr">"first_byte_time"</span>:<span class="number">-0</span>,<span class="attr">"upstream_response_time"</span>:<span class="string">"0.258"</span>,<span class="attr">"bytes_sent"</span>:<span class="string">"8364"</span>,<span class="attr">"download_time"</span>:<span class="number">-0</span>,<span class="attr">"half_rtt_time"</span>:<span class="number">2685.709</span>,<span class="attr">"request_time"</span>:<span class="number">0.259</span>&#125;</span><br></pre></td></tr></table></figure>
<p>总结：2.4亿条原始nginx日志，原始JSON格式数据大小240G，CSV格式的数据大小为93G，存储到ClickHouse后占用磁盘大小12G左右。不管以哪种方式存储，ClickHouse具体非常好的数据压缩比。目前线上是从kafka消费JSON格式数据入库到ClickHouse。如果数据表字段少一点或者是数据都存储在一台机器上，ClickHouse压缩比会更高。<a href="https://zhuanlan.zhihu.com/p/32662689" target="_blank" rel="noopener">ClickHouse数据压缩</a>这篇文章有测试过1亿条数据记录ES存储磁盘占用33GB，ClickHouse磁盘占用1.4GB。</p>
<h1 id="ClickHouse解压缩"><a href="#ClickHouse解压缩" class="headerlink" title="ClickHouse解压缩"></a>ClickHouse解压缩</h1><p>当我们在查询ClickHouse数据库数据时，如果采用perf工具对ClickHouse进程采样，会发现LZ_decompress_fast方法占用的CPU时间最多。</p>
<p><img src="/images/057302aba5041790af404c2c781c4dd3.png" alt="sd"></p>
<p>ClickHouse数据以压缩的形式存储在本地磁盘中，当数据查询时ClickHouse为了减少CPU使用资源会尽量少做一些事情。在许多情况下，所有潜在的耗时计算都已经得到了很好的优化，而且用户编写了一个经过深思熟虑的查询，那么剩下要做的就是执行解压缩。</p>
<p>那么为什么LZ4解压缩成为一个瓶颈呢？<a href="https://github.com/lz4/lz4/" target="_blank" rel="noopener">LZ4</a>看起来是一种非常轻的算法:数据解压缩速率通常是每个处理器内核1到3 GB/s，具体取决于数据。这比典型的磁盘子系统快得多。此外，我们使用所有可用的中央处理器内核，解压缩在所有物理内核之间线性扩展。</p>
<p>首先，如果数据压缩率很高，则磁盘上数据占用空间就很小，在读取数据时磁盘IO会比较低，但是如果待解压的数据量很大则会影响到CPU使用率。在LZ4的情况下，解压缩数据所需的工作量几乎与解压缩数据本身的量成正比；其次，如果数据被缓存，你可能根本不需要从磁盘读取数据。可以依赖页面缓存或使用自己的缓存。缓存在面向列的数据库中更有效，因为只有经常使用的列保留在缓存中。这就是为什么LZ4经常成为CPU负载的瓶颈。</p>
<p>在官方的这篇博客中<a href="https://habr.com/en/company/yandex/blog/457612/" target="_blank" rel="noopener">How to speed up LZ4 decompression in ClickHouse</a>，作者反馈有人希望ClickHoouse不要以数据压缩的方式存储数据，因为反馈者认为数据查询时是因为数据解压拖慢了整个查询进度，并且这个人还在github上提了一个<a href="https://github.com/yandex/ClickHouse/pull/1045" target="_blank" rel="noopener">PR</a>，最后维护者觉得<code>Ok. If you are not going to use this compression method, it&#39;s not worth to implement.</code>。</p>
<p>如果可以使用缓存，为何ClickHouse不把解压后的数据存在缓存中呢，这样可以减少很多数据解压的场景，ClickHouse也提供了cache配置项<a href="https://clickhouse.yandex/docs/en/operations/settings/settings/#use_uncompressed_cache" target="_blank" rel="noopener">the cache of decompressed blocks</a>。在博客中作者认为这种方式对内存是极大的浪费，并且只有在查询数据量很小的场景下是有用的。我个人也觉得如果缓存住解压后的数据，ClickHouse进程肯定会经常发生OOM。ClickHouse高效的数据压缩设计其实是一个很好的设计方案，首先可以减小磁盘的数据占用；其次在shard的replica副本个数超过1时，replica之间的数据同步也可以更高效。</p>
<p>目前在生产环境中，ClickHouse简单数据查询P99的时间还是在秒级返回，只有在复杂的数据查询场景下查询时间会增加到几秒，例如多个表join，其实在这个场景下更多的做法应该是优化SQL查询语句，尽量避免大量表join查询。</p>
<p><a href="https://habr.com/en/company/yandex/blog/457612/" target="_blank" rel="noopener">How to speed up LZ4 decompression in ClickHouse</a>这篇官方博客中作者还提到了LZ4是如何工作的以及数据解压缩的优化手段。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/24/压缩算法概览/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KnifeFly">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/24/压缩算法概览/" itemprop="url">压缩算法概览</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-24T14:21:29+08:00">
                2019-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="压缩算法概览"><a href="#压缩算法概览" class="headerlink" title="压缩算法概览"></a>压缩算法概览</h1><blockquote>
<p>压缩的理论（它与<a href="https://zh.wikipedia.org/wiki/算法信息论" target="_blank" rel="noopener">算法信息论</a>密切相关）以及<a href="https://zh.wikipedia.org/wiki/率失真理论" target="_blank" rel="noopener">率有损理论</a>，这个领域的研究工作主要是由美国学者<a href="https://zh.wikipedia.org/wiki/克劳德·香农" target="_blank" rel="noopener">克劳德·香农</a>（Claude Elwood Shannon）奠定的，他在二十世纪四十年代末期及五十年代早期发表了这方面的基础性的论文。</p>
<p>Lempel-Ziv（LZ）压缩方法是最流行的无损存储算法之一。<a href="https://zh.wikipedia.org/wiki/DEFLATE" target="_blank" rel="noopener">DEFLATE</a>是LZ的一个变体，它针对解压速度与压缩率进行了优化，虽然它的压缩速度可能非常缓慢，<a href="https://zh.wikipedia.org/w/index.php?title=PKZIP&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">PKZIP</a>、<a href="https://zh.wikipedia.org/wiki/Gzip" target="_blank" rel="noopener">gzip</a>以及<a href="https://zh.wikipedia.org/wiki/PNG" target="_blank" rel="noopener">PNG</a>都在使用DEFLATE。<a href="https://zh.wikipedia.org/wiki/LZW" target="_blank" rel="noopener">LZW</a>（Lempel-Ziv-Welch）是<a href="https://zh.wikipedia.org/wiki/Unisys" target="_blank" rel="noopener">Unisys</a>的<a href="https://zh.wikipedia.org/wiki/专利" target="_blank" rel="noopener">专利</a>，直到2003年6月专利到期限，这种方法用于<a href="https://zh.wikipedia.org/wiki/GIF" target="_blank" rel="noopener">GIF</a>图像。另外值得一提的是LZR （LZ-Renau） 方法，它是Zip方法的基础。LZ方法使用基于表格的压缩模型，其中表格中的条目用重复的数据串替换。对于大多数的LZ方法来说，这个表格是从最初的输入数据动态生成的。这个表格经常采用<a href="https://zh.wikipedia.org/wiki/霍夫曼编码" target="_blank" rel="noopener">霍夫曼编码</a>维护（例如SHRI、LZX）。 当前一个性能良好基于LZ的编码机制是<a href="https://zh.wikipedia.org/w/index.php?title=LZX_(algorithm" target="_blank" rel="noopener">LZX</a>&amp;action=edit&amp;redlink=1)，它用于微软公司的<a href="https://zh.wikipedia.org/wiki/CAB" target="_blank" rel="noopener">CAB</a>格式。</p>
</blockquote>
<p>压缩算法分为两个层面：</p>
<ol>
<li>熵编码：根据消息中每个符号出现的概率，然后通过某种映射用更短的符号替代原来的符号，核心在于提高符号的信息熵，哈夫曼编码最为典型。</li>
<li>字典编码：提取信息中的重复部分作为字典，然后通过字典和某种映射替代这些重复的部分，核心在于替代重复，LZ77和LZ78算法最为典型。</li>
</ol>
<h1 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h1><p><strong>Gzip</strong>是若干种<a href="https://zh.wikipedia.org/wiki/文件压缩" target="_blank" rel="noopener">文件压缩</a><a href="https://zh.wikipedia.org/wiki/程序" target="_blank" rel="noopener">程序</a>的简称，通常指<a href="https://zh.wikipedia.org/wiki/GNU計劃" target="_blank" rel="noopener">GNU计划</a>的实现，gzip的基础是<a href="https://zh.wikipedia.org/wiki/DEFLATE" target="_blank" rel="noopener">DEFLATE</a>，DEFLATE是<a href="https://zh.wikipedia.org/wiki/LZ77与LZ78" target="_blank" rel="noopener">LZ77</a>与<a href="https://zh.wikipedia.org/wiki/哈夫曼编码" target="_blank" rel="noopener">哈夫曼编码</a>的一个组合体。Gzip编码格式在<a href="https://link.juejin.im/?target=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc1952" target="_blank" rel="noopener">RFC 1952</a>中定义。</p>
<p>Gzip亚搜文件格式如下为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ID1 | ID2 | CM | FLG | MTIME（4字节） | XFL | OS | ---&gt; more</span><br></pre></td></tr></table></figure>
<p>在Centos操作系统中空Gzip文件文件大小为26字节，用二进制查看工具查看文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000 8b1f 0808 c8fb 5d60 0300 6568 6c6c 006f</span><br><span class="line">0000020 0003 0000 0000 0000 0000</span><br><span class="line">0000032</span><br></pre></td></tr></table></figure>
<ul>
<li>其中 ID1 和 ID2 分别是 0x1f 和 0x8b，用来标识文件格式是 gzip</li>
<li>CM 标识 加密算法，目前 0-7是保留字，8 指的是 <a href="https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FDEFLATE" target="_blank" rel="noopener">deflate 算法</a></li>
<li>FLG标志位</li>
<li>MTIME 指的是源文件最近一次修改时间，存的是 Unix 时间戳</li>
<li>XFL defalte 算法中 2 表示使用压缩率最高的算法，4 表示使用压缩速度最快的算法</li>
<li>OS 标识压缩程序运行的文件系统，以处理 EOF 等的问题</li>
<li>more 后面是根据 FLG 的开启情况决定的，可能会有 循环冗余校验码、源文件长度、附加信息等多种其他信息</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/08/24/压缩算法概览/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/24/ClickHouse运营总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KnifeFly">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/24/ClickHouse运营总结/" itemprop="url">ClickHouse 运营总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-24T11:37:28+08:00">
                2019-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="ClickHouse-运营总结"><a href="#ClickHouse-运营总结" class="headerlink" title="ClickHouse 运营总结"></a>ClickHouse 运营总结</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ClickHouse 是俄罗斯 Yandex 公司所开源的一款用于大数据实时分析的列式数据库管理系统，采用 C++ 编写，对于百亿级数据的查询聚合能达到秒级返回。</p>
<p>ClickHouse 的主要优点有：</p>
<ol>
<li>为了高效的使用CPU，数据不仅仅按列存储，同时还按向量进行处理；</li>
<li>数据压缩空间大，减少io；处理单查询高吞吐量每台服务器每秒最多数十亿行；</li>
<li>索引非B树结构，不需要满足最左原则；只要过滤条件在索引列中包含即可；即使在使用的数据不在索引中，由于各种并行处理机制ClickHouse全表扫描的速度也很快；</li>
<li>写入速度非常快，50-200M/s，对于大量的数据更新非常适用。</li>
</ol>
<p>而为了达到“快”的效果，ClickHouse 付出了如下的代价：</p>
<ol>
<li>不支持事务，不支持真正的删除/更新；</li>
<li>不支持高并发，官方建议 QPS 为100，可以通过修改配置文件增加连接数，但是在服务器足够好的情况下；</li>
<li>SQL 满足日常使用80%以上的语法，join 写法比较特殊；最新版已支持类似 SQL 的 join，但性能不好；</li>
<li>尽量做1000条以上批量的写入，避免逐行 insert 或小批量的 insert，update，delete 操作，因为 ClickHouse 底层会不断的做异步的数据合并，会影响查询性能，这个在做实时数据写入的时候要尽量避开；</li>
<li>ClickHouse 快是因为采用了并行处理机制，即使一个查询，也会用服务器一半的cpu去执行，所以 ClickHouse 不能支持高并发的使用场景，默认单查询使用cpu核数为服务器核数的一半，安装时会自动识别服务器核数，可以通过配置文件修改该参数。</li>
</ol>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/08/24/ClickHouse运营总结/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/15/Spark 内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KnifeFly">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/15/Spark 内存管理/" itemprop="url">Spark 内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-15T20:01:29+08:00">
                2019-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="https://www.ibm.com/developerworks/cn/analytics/library/ba-cn-apache-spark-memory-management/index.html" target="_blank" rel="noopener">原文地址</a></p>
<p>Spark 作为一个基于内存的分布式计算引擎，其内存管理模块在整个系统中扮演着非常重要的角色。理解 Spark 内存管理的基本原理，有助于更好地开发 Spark 应用程序和进行性能调优。本文旨在梳理出 Spark 内存管理的脉络，抛砖引玉，引出读者对这个话题的深入探讨。本文中阐述的原理基于 Spark 2.1 版本，阅读本文需要读者有一定的 Spark 和 Java 基础，了解 RDD、Shuffle、JVM 等相关概念。</p>
<p>在执行 Spark 的应用程序时，Spark 集群会启动 Driver 和 Executor 两种 JVM 进程，前者为主控进程，负责创建 Spark 上下文，提交 Spark 作业（Job），并将作业转化为计算任务（Task），在各个 Executor 进程间协调任务的调度，后者负责在工作节点上执行具体的计算任务，并将结果返回给 Driver，同时为需要持久化的 RDD 提供存储功能[1]。由于 Driver 的内存管理相对来说较为简单，本文主要对 Executor 的内存管理进行分析，下文中的 Spark 内存均特指 Executor 的内存。</p>
<h2 id="1-堆内和堆外内存规划"><a href="#1-堆内和堆外内存规划" class="headerlink" title="1. 堆内和堆外内存规划"></a>1. 堆内和堆外内存规划</h2><p>作为一个 JVM 进程，Executor 的内存管理建立在 JVM 的内存管理之上，Spark 对 JVM 的堆内（On-heap）空间进行了更为详细的分配，以充分利用内存。同时，Spark 引入了堆外（Off-heap）内存，使之可以直接在工作节点的系统内存中开辟空间，进一步优化了内存的使用。</p>
<h5 id="图-1-堆内和堆外内存示意图"><a href="#图-1-堆内和堆外内存示意图" class="headerlink" title="图 1 . 堆内和堆外内存示意图"></a>图 1 . 堆内和堆外内存示意图</h5><p><img src="https://www.ibm.com/developerworks/cn/analytics/library/ba-cn-apache-spark-memory-management/image001.png" alt="img"></p>
<h3 id="1-1-堆内内存"><a href="#1-1-堆内内存" class="headerlink" title="1.1 堆内内存"></a>1.1 堆内内存</h3><p>堆内内存的大小，由 Spark 应用程序启动时的 –executor-memory 或 spark.executor.memory 参数配置。Executor 内运行的并发任务共享 JVM 堆内内存，这些任务在缓存 RDD 数据和广播（Broadcast）数据时占用的内存被规划为存储（Storage）内存，而这些任务在执行 Shuffle 时占用的内存被规划为执行（Execution）内存，剩余的部分不做特殊规划，那些 Spark 内部的对象实例，或者用户定义的 Spark 应用程序中的对象实例，均占用剩余的空间。不同的管理模式下，这三部分占用的空间大小各不相同（下面第 2 小节会进行介绍）。</p>
<p>Spark 对堆内内存的管理是一种逻辑上的”规划式”的管理，因为对象实例占用内存的申请和释放都由 JVM 完成，Spark 只能在申请后和释放前<strong>记录</strong>这些内存，我们来看其具体流程：</p>
<ul>
<li><strong>申请内存</strong>：</li>
</ul>
<ol>
<li>Spark 在代码中 new 一个对象实例</li>
<li>JVM 从堆内内存分配空间，创建对象并返回对象引用</li>
<li>Spark 保存该对象的引用，记录该对象占用的内存</li>
</ol>
<ul>
<li><strong>释放内存</strong>：</li>
</ul>
<ol>
<li>Spark 记录该对象释放的内存，删除该对象的引用</li>
<li>等待 JVM 的垃圾回收机制释放该对象占用的堆内内存</li>
</ol>
<p>我们知道，JVM 的对象可以以序列化的方式存储，序列化的过程是将对象转换为二进制字节流，本质上可以理解为将非连续空间的链式存储转化为连续空间或块存储，在访问时则需要进行序列化的逆过程——反序列化，将字节流转化为对象，序列化的方式可以节省存储空间，但增加了存储和读取时候的计算开销。</p>
<p>对于 Spark 中序列化的对象，由于是字节流的形式，其占用的内存大小可直接计算，而对于非序列化的对象，其占用的内存是通过周期性地采样近似估算而得，即并不是每次新增的数据项都会计算一次占用的内存大小，这种方法降低了时间开销但是有可能误差较大，导致某一时刻的实际内存有可能远远超出预期[2]。此外，在被 Spark 标记为释放的对象实例，很有可能在实际上并没有被 JVM 回收，导致实际可用的内存小于 Spark 记录的可用内存。所以 Spark 并不能准确记录实际可用的堆内内存，从而也就无法完全避免内存溢出（OOM, Out of Memory）的异常。</p>
<p>虽然不能精准控制堆内内存的申请和释放，但 Spark 通过对存储内存和执行内存各自独立的规划管理，可以决定是否要在存储内存里缓存新的 RDD，以及是否为新的任务分配执行内存，在一定程度上可以提升内存的利用率，减少异常的出现。</p>
<h3 id="1-2-堆外内存"><a href="#1-2-堆外内存" class="headerlink" title="1.2 堆外内存"></a>1.2 堆外内存</h3><p>为了进一步优化内存的使用以及提高 Shuffle 时排序的效率，Spark 引入了堆外（Off-heap）内存，使之可以直接在工作节点的系统内存中开辟空间，存储经过序列化的二进制数据。利用 JDK Unsafe API（从 Spark 2.0 开始，在管理堆外的存储内存时不再基于 Tachyon，而是与堆外的执行内存一样，基于 JDK Unsafe API 实现[3]），Spark 可以直接操作系统堆外内存，减少了不必要的内存开销，以及频繁的 GC 扫描和回收，提升了处理性能。堆外内存可以被精确地申请和释放，而且序列化的数据占用的空间可以被精确计算，所以相比堆内内存来说降低了管理的难度，也降低了误差。</p>
<p>在默认情况下堆外内存并不启用，可通过配置 spark.memory.offHeap.enabled 参数启用，并由 spark.memory.offHeap.size 参数设定堆外空间的大小。除了没有 other 空间，堆外内存与堆内内存的划分方式相同，所有运行中的并发任务共享存储内存和执行内存。</p>
<h3 id="1-3-内存管理接口"><a href="#1-3-内存管理接口" class="headerlink" title="1.3 内存管理接口"></a>1.3 内存管理接口</h3><p>Spark 为存储内存和执行内存的管理提供了统一的接口——MemoryManager，同一个 Executor 内的任务都调用这个接口的方法来申请或释放内存:</p>
<h4 id="清单-1-内存管理接口的主要方法"><a href="#清单-1-内存管理接口的主要方法" class="headerlink" title="清单 1 . 内存管理接口的主要方法"></a>清单 1 . 内存管理接口的主要方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//申请存储内存``def acquireStorageMemory(blockId: BlockId, numBytes: Long, memoryMode: MemoryMode): Boolean``//申请展开内存``def acquireUnrollMemory(blockId: BlockId, numBytes: Long, memoryMode: MemoryMode): Boolean``//申请执行内存``def acquireExecutionMemory(numBytes: Long, taskAttemptId: Long, memoryMode: MemoryMode): Long``//释放存储内存``def releaseStorageMemory(numBytes: Long, memoryMode: MemoryMode): Unit``//释放执行内存``def releaseExecutionMemory(numBytes: Long, taskAttemptId: Long, memoryMode: MemoryMode): Unit``//释放展开内存``def releaseUnrollMemory(numBytes: Long, memoryMode: MemoryMode): Unit</span><br></pre></td></tr></table></figure>
<p>我们看到，在调用这些方法时都需要指定其内存模式（MemoryMode），这个参数决定了是在堆内还是堆外完成这次操作。</p>
<p>MemoryManager 的具体实现上，Spark 1.6 之后默认为统一管理（<a href="https://github.com/apache/spark/blob/v2.1.0/core/src/main/scala/org/apache/spark/memory/UnifiedMemoryManager.scala" target="_blank" rel="noopener">Unified Memory Manager</a>）方式，1.6 之前采用的静态管理（<a href="https://github.com/apache/spark/blob/v2.1.0/core/src/main/scala/org/apache/spark/memory/StaticMemoryManager.scala" target="_blank" rel="noopener">Static Memory Manager</a>）方式仍被保留，可通过配置 spark.memory.useLegacyMode 参数启用。两种方式的区别在于对空间分配的方式，下面的第 2 小节会分别对这两种方式进行介绍。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/07/15/Spark 内存管理/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/15/YARN Container内存控制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KnifeFly">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/15/YARN Container内存控制/" itemprop="url">YARN Container 内存控制策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-15T10:01:29+08:00">
                2019-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="YARN-Container-内存控制"><a href="#YARN-Container-内存控制" class="headerlink" title="YARN Container 内存控制"></a>YARN Container 内存控制</h1><p>YARN 2.6 版本中对于Container内存控制策略比较单一，程序中有一个监控线程不停地检测各个Container的内存使用情况，只要物理内存或者虚拟内存在超过阈值之后，就会kill该container。有两个配置项与此相关，分别是<code>yarn.nodemanager.pmem-check-enabled</code>和<code>yarn.nodemanager.vmem-check-enabled</code>，在默认情况下，这两个配置项都为true。</p>
<p>YARN 3.2版本中提供更为精细的三种内存控制策略，主要分为三种：</p>
<ol>
<li>监控线程定时轮询各个container的内存占用情况，如果超过限制则kill container</li>
<li>使用linux cgroup内核的OOM killer机制，严格控制container内存</li>
<li>弹性内存控制策略，只有当整个系统内存超过限制后才会kill container</li>
</ol>
<p>第1种内存控制策略比较好理解，就是开一个监控线程不停地监控container的使用情况，遇到阈值超过控制才会kill container，这种监控方式是在应用程序级别进行检测，有一定的延迟性。第2种和第3种内存控制策略使用了linux内核的OOM killer机制，当整个系统内存不足时，内核会选出score分数最高的进程，然后kill，区别在于，前者是严格控制，后者是弹性控制，严格控制指的是只要container内存超过阈值就Kill，后者是只要container的内存使用没有超过系统可使用的内存，则不会被kill。</p>
<p>弹性内存控制策略配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.container-executor.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.yarn.server.nodemanager.LinuxContainerExecutor<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.memory.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.runtime.linux.allowed-runtimes<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>default<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.vmem-check-enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.pmem-check-enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.vmem-pmem-ratio<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>3.5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.memory.enforced<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.elastic-memory-control.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>具体配置项参考：<a href="https://hadoop.apache.org/docs/current3/hadoop-yarn/hadoop-yarn-site/NodeManagerCGroupsMemory.html" target="_blank" rel="noopener">官方文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/28/ClickHouse高可用集群搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KnifeFly">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/28/ClickHouse高可用集群搭建/" itemprop="url">ClickHouse 高可用集群设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T19:19:29+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>ClickHouse采用分片 + 副本实现高可用集群，下面以4台服务器为例子，讲述设计一个高可用的分布式集群需要注意的几个地方。</p>
<p>建立可横向扩展的数据服务集群，分片技术通常是必须的，MongoDB提供了原生的数据库分片技术，减小MySQL分库分表带来的麻烦。ClickHouse同样支持分片技术，假设4台机器，每台机器安装一个CH的示例，则表示有4个分片，每个分片的副本设置为1，对于这种集群设置不存在高可用可言，因为如果有一台机器挂了则整个ClickHouse集群不可用。</p>
<p>只有分片 + 副本才可实现高可用集群，可根据集群机器资源情况设置单分片副本数量，本次采用4台机器服务集群搭建，4个分片，每个分片两个副本。需要在每台机器上开启两个ClickHouse示例，注意不同示例需要设置不同的数据目录以及绑定不同的端口。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/05/28/ClickHouse高可用集群搭建/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/27/ClickHouse系统架构概览/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KnifeFly">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/27/ClickHouse系统架构概览/" itemprop="url">ClickHouse系统架构概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-27T21:01:29+08:00">
                2019-05-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="ClickHouse系统架构概述"><a href="#ClickHouse系统架构概述" class="headerlink" title="ClickHouse系统架构概述"></a>ClickHouse系统架构概述</h1><h2 id="ClickHouse独特功能"><a href="#ClickHouse独特功能" class="headerlink" title="ClickHouse独特功能"></a>ClickHouse独特功能</h2><h3 id="真正的列式数据库管理系统"><a href="#真正的列式数据库管理系统" class="headerlink" title="真正的列式数据库管理系统"></a>真正的列式数据库管理系统</h3><p>在一个真正的列式数据库管理系统中，除了数据本身外不应该存在其他额外的数据。这意味着为了避免在值旁边存储它们的长度“number”，你必须支持固定长度数值类型。例如，10亿个UInt8类型的数据在未压缩的情况下大约消耗1GB左右的空间，如果不是这样的话，这将对CPU的使用产生强烈影响。即使是在未压缩的情况下，紧凑的存储数据也是非常重要的，因为解压缩的速度主要取决于未压缩数据的大小。</p>
<p>这是非常值得注意的，因为在一些其他系统中也可以将不同的列分别进行存储，但由于对其他场景进行的优化，使其无法有效的处理分析查询。例如： HBase，BigTable，Cassandra，HyperTable。在这些系统中，你可以得到每秒数十万的吞吐能力，但是无法得到每秒几亿行的吞吐能力。</p>
<p>需要说明的是，ClickHouse不单单是一个数据库， 它是一个数据库管理系统。因为它允许在运行时创建表和数据库、加载数据和运行查询，而无需重新配置或重启服务。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/05/27/ClickHouse系统架构概览/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/05/Raft 一致性算法论文译文/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KnifeFly">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/05/Raft 一致性算法论文译文/" itemprop="url">Raft 一致性算法论文译文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-05T20:04:50+08:00">
                2019-04-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="Raft-一致性算法论文译文"><a href="#Raft-一致性算法论文译文" class="headerlink" title="Raft 一致性算法论文译文"></a>Raft 一致性算法论文译文</h1><p>Raft论文翻译转载自<a href="http://blog.luoyuanhang.com/2017/02/02/raft-paper-in-zh-CN/" target="_blank" rel="noopener">Raft 一致性算法论文译文</a></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>Raft 是一种用来管理日志复制的一致性算法。它和 Paxos 的性能和功能是一样的，但是它和 Paxos 的结构不一样；这使得 Raft 更容易理解并且更易于建立实际的系统。为了提高理解性，Raft 将一致性算法分为了几个部分，例如领导选取（leader selection），日志复制（log replication）和安全性（safety），同时它使用了更强的一致性来减少了必须需要考虑的状态。从用户学习的结果来看，Raft 比 Paxos 更容易学会。Raft 还包括了一种新的机制来使得动态改变集群成员，它使用重叠大多数（overlapping majorities）来保证安全。</p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>一致性算法允许一组机器像一个整体一样工作，即使其中的一些机器出了错误也能正常工作。正因为此，他们扮演着建立大规模可靠的软件系统的关键角色。在过去的十年中 Paxos 一直都主导着有关一致性算法的讨论：大多数一致性算法的实现都基于它或者受它影响，并且 Paxos 也成为了教学生关于一致性知识的主要工具。</p>
<p>不幸的是，尽管在降低它的复杂性方面做了许多努力，Paxos 依旧很难理解。并且，Paxos 需要经过复杂的修改才能应用于实际中。这些导致了系统构构建者和学生都十分头疼。</p>
<p>在被 Paxos 折磨之后，我们开始寻找一种在系统构建和教学上更好的新的一致性算法。我们的首要目标是让它易于理解：我们能不能定义一种面向实际系统的一致性算法并且比 Paxos 更容易学习呢？并且，我们希望这种算法能凭直觉就能明白，这对于一个系统构建者来说是十分必要的。对于一个算法，不仅仅是让它工作起来很重要，知道它是如何工作的更重要。</p>
<p>我们工作的结果是一种新的一致性算法，叫做 Raft。在设计 Raft 的过程中我们应用了许多专门的技巧来提升理解性，包括算法分解（分为领导选取（leader selection），日志复制（log replication）和安全性（safety））和减少状态（state space reduction）（相对于 Paxos，Raft 减少了非确定性的程度和服务器互相不一致的方式）。在两所学校的43个学生的研究中发现，Raft 比 Paxos 要更容易理解：在学习了两种算法之后，其中的33个学生回答 Raft 的问题要比回答 Paxos 的问题要好。</p>
<p>Raft 算法和现在一些已经有的算法在一些地方很相似（主要是 <a href="http://www.pmg.csail.mit.edu/papers/vr.pdf" target="_blank" rel="noopener">Oki 和 Liskov 的 Viewstamped Replication</a>。但是 Raft 有几个新的特性：</p>
<ul>
<li>强领导者（Strong Leader）：Raft 使用一种比其他算法更强的领导形式。例如，日志条目只从领导者发送向其他服务器。这样就简化了对日志复制的管理，使得 Raft 更易于理解。</li>
<li>领导选取（Leader Selection）：Raft 使用随机定时器来选取领导者。这种方式仅仅是在所有算法都需要实现的心跳机制上增加了一点变化，它使得在解决冲突时更简单和快速。</li>
<li>成员变化（Membership Change）：Raft 为了调整集群中成员关系使用了新的联合一致性（joint consensus）的方法，这种方法中大多数不同配置的机器在转换关系的时候会交迭（overlap）。这使得在配置改变的时候，集群能够继续操作。</li>
</ul>
<p>我们认为，Raft 在教学方面和实际实现方面比 Paxos 和其他算法更出众。它比其他算法更简单、更容易理解；它能满足一个实际系统的需求；它拥有许多开源的实现并且被许多公司所使用；它的安全特性已经被证明；并且它的效率和其他算法相比也具有竞争力。</p>
<p>这篇论文剩下的部分会讲如下内容：复制状态机（replicated state machine）问题（第2节），讨论 Paxos 的优缺点（第3节），讨论我们用的为了达到提升理解性的方法（第4节），陈述 Raft 一致性算法（第5~8节），评价 Raft 算法（第9节），对相关工作的讨论（第10节）。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/04/05/Raft 一致性算法论文译文/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/15/优秀的 Go存储开源项目和库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KnifeFly">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/15/优秀的 Go存储开源项目和库/" itemprop="url">优秀的 Go存储开源项目和库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-15T20:18:29+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="优秀的-Go存储开源项目和库"><a href="#优秀的-Go存储开源项目和库" class="headerlink" title="优秀的 Go存储开源项目和库"></a>优秀的 Go存储开源项目和库</h1><p>A curated list of awesome Go storage projects and libraries. Inspired by <a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">awesome-go</a>.</p>
<h3 id="Contributing"><a href="#Contributing" class="headerlink" title="Contributing"></a>Contributing</h3><p>Please take a quick gander at the <a href="https://github.com/gostor/awesome-go-storage/blob/master/CONTRIBUTING.md" target="_blank" rel="noopener">contribution guidelines</a> first. Thanks to all <a href="https://github.com/gostor/awesome-go-storage/graphs/contributors" target="_blank" rel="noopener">contributors</a>; you rock!</p>
<h4 id="If-you-see-a-package-or-project-here-that-is-no-longer-maintained-or-is-not-a-good-fit-please-submit-a-pull-request-to-improve-this-file-Thank-you"><a href="#If-you-see-a-package-or-project-here-that-is-no-longer-maintained-or-is-not-a-good-fit-please-submit-a-pull-request-to-improve-this-file-Thank-you" class="headerlink" title="If you see a package or project here that is no longer maintained or is not a good fit, please submit a pull request to improve this file. Thank you!"></a><em>If you see a package or project here that is no longer maintained or is not a good fit, please submit a pull request to improve this file. Thank you!</em></h4><h3 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h3><ul>
<li>Awesome Go Storage<ul>
<li><a href="https://github.com/gostor/awesome-go-storage#storage-server" target="_blank" rel="noopener">Storage Server</a></li>
<li><a href="https://github.com/gostor/awesome-go-storage#key-value-store" target="_blank" rel="noopener">Key-Value Store</a></li>
<li><a href="https://github.com/gostor/awesome-go-storage#file-system" target="_blank" rel="noopener">File System</a></li>
<li><a href="https://github.com/gostor/awesome-go-storage#database" target="_blank" rel="noopener">Database</a></li>
<li><a href="https://github.com/gostor/awesome-go-storage#database-drivers" target="_blank" rel="noopener">Database Drivers</a></li>
</ul>
</li>
</ul>
<h2 id="Storage-Server"><a href="#Storage-Server" class="headerlink" title="Storage Server"></a>Storage Server</h2><p><em>Storage Servers implemented in Go.</em></p>
<ul>
<li><a href="https://github.com/minio/minio" target="_blank" rel="noopener">minio</a> - Minio is an open source object storage server compatible with Amazon S3 APIs.</li>
<li><a href="https://github.com/ncw/rclone" target="_blank" rel="noopener">rclone</a> - “rsync for cloud storage” - Google Drive, Amazon Drive, S3, Dropbox, Backblaze B2, One Drive, Swift, Hubic, Cloudfile…</li>
<li><a href="https://github.com/perkeep/perkeep" target="_blank" rel="noopener">perkeep</a> - Perkeep is your personal storage system for life: a way of storing, syncing, sharing, modelling and backing up content.</li>
<li><a href="https://github.com/s3git/s3git" target="_blank" rel="noopener">s3git</a> - Git for Cloud Storage. Distributed Version Control for Data.</li>
<li><a href="https://github.com/storj/storj" target="_blank" rel="noopener">storj</a> - Decentralized cloud object storage that is affordable, easy to use, private, and secure.</li>
<li><a href="https://github.com/rook/rook" target="_blank" rel="noopener">rook</a> - Open, Cloud Native, and Universal Distributed Storage.</li>
<li><a href="https://github.com/rancher/longhorn" target="_blank" rel="noopener">longhorn</a> Longhorn is an open source persistent block storage server delivered via containers.</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/03/15/优秀的 Go存储开源项目和库/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/kafka 高可用设计(上)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KnifeFly">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/14/kafka 高可用设计(上)/" itemprop="url">kafka高可用设计(上)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-14T23:01:22+08:00">
                2019-02-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>本文转发自<a href="http://www.jasongj.com/" target="_blank" rel="noopener"><strong>技术世界</strong></a>，<a href="http://www.jasongj.com/2015/04/24/KafkaColumn2" target="_blank" rel="noopener">原文链接</a>　<a href="http://www.jasongj.com/2015/04/24/KafkaColumn2" target="_blank" rel="noopener">http://www.jasongj.com/2015/04/24/KafkaColumn2</a></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>　　Kafka在0.8以前的版本中，并不提供High Availablity机制，一旦一个或多个Broker宕机，则宕机期间其上所有Partition都无法继续提供服务。若该Broker永远不能再恢复，亦或磁盘故障，则其上数据将丢失。而Kafka的设计目标之一即是提供数据持久化，同时对于分布式系统来说，尤其当集群规模上升到一定程度后，一台或者多台机器宕机的可能性大大提高，对于Failover机制的需求非常高。因此，Kafka从0.8开始提供High Availability机制。本文从Data Replication和Leader Election两方面介绍了Kafka的HA机制。</p>
<h1 id="Kafka为何需要High-Available"><a href="#Kafka为何需要High-Available" class="headerlink" title="Kafka为何需要High Available"></a>Kafka为何需要High Available</h1><h2 id="为何需要Replication"><a href="#为何需要Replication" class="headerlink" title="为何需要Replication"></a>为何需要Replication</h2><p>　　在Kafka在0.8以前的版本中，是没有Replication的，一旦某一个Broker宕机，则其上所有的Partition数据都不可被消费，这与Kafka数据持久性及Delivery Guarantee的设计目标相悖。同时Producer都不能再将数据存于这些Partition中。</p>
<ul>
<li>如果Producer使用同步模式则Producer会在尝试重新发送<code>message.send.max.retries</code>（默认值为3）次后抛出Exception，用户可以选择停止发送后续数据也可选择继续选择发送。而前者会造成数据的阻塞，后者会造成本应发往该Broker的数据的丢失。</li>
<li>如果Producer使用异步模式，则Producer会尝试重新发送<code>message.send.max.retries</code>（默认值为3）次后记录该异常并继续发送后续数据，这会造成数据丢失并且用户只能通过日志发现该问题。</li>
</ul>
<p>　　由此可见，在没有Replication的情况下，一旦某机器宕机或者某个Broker停止工作则会造成整个系统的可用性降低。随着集群规模的增加，整个集群中出现该类异常的几率大大增加，因此对于生产系统而言Replication机制的引入非常重要。 　　</p>
<h2 id="为何需要Leader-Election"><a href="#为何需要Leader-Election" class="headerlink" title="为何需要Leader Election"></a>为何需要Leader Election</h2><p>　　（本文所述Leader Election主要指Replica之间的Leader Election）<br>　　引入Replication之后，同一个Partition可能会有多个Replica，而这时需要在这些Replica中选出一个Leader，Producer和Consumer只与这个Leader交互，其它Replica作为Follower从Leader中复制数据。<br>　　因为需要保证同一个Partition的多个Replica之间的数据一致性（其中一个宕机后其它Replica必须要能继续服务并且即不能造成数据重复也不能造成数据丢失）。如果没有一个Leader，所有Replica都可同时读/写数据，那就需要保证多个Replica之间互相（N×N条通路）同步数据，数据的一致性和有序性非常难保证，大大增加了Replication实现的复杂性，同时也增加了出现异常的几率。而引入Leader后，只有Leader负责数据读写，Follower只向Leader顺序Fetch数据（N条通路），系统更加简单且高效。 　　 　　</p>
<h1 id="Kafka-HA设计解析"><a href="#Kafka-HA设计解析" class="headerlink" title="Kafka HA设计解析"></a>Kafka HA设计解析</h1><h2 id="如何将所有Replica均匀分布到整个集群"><a href="#如何将所有Replica均匀分布到整个集群" class="headerlink" title="如何将所有Replica均匀分布到整个集群"></a>如何将所有Replica均匀分布到整个集群</h2><p>　　为了更好的做负载均衡，Kafka尽量将所有的Partition均匀分配到整个集群上。一个典型的部署方式是一个Topic的Partition数量大于Broker的数量。同时为了提高Kafka的容错能力，也需要将同一个Partition的Replica尽量分散到不同的机器。实际上，如果所有的Replica都在同一个Broker上，那一旦该Broker宕机，该Partition的所有Replica都无法工作，也就达不到HA的效果。同时，如果某个Broker宕机了，需要保证它上面的负载可以被均匀的分配到其它幸存的所有Broker上。<br>　　Kafka分配Replica的算法如下：</p>
<ol>
<li>将所有Broker（假设共n个Broker）和待分配的Partition排序</li>
<li>将第i个Partition分配到第（i mod n）个Broker上</li>
<li>将第i个Partition的第j个Replica分配到第（(i + j) mod n）个Broker上</li>
</ol>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/02/14/kafka 高可用设计(上)/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Yujie" />
          <p class="site-author-name" itemprop="name">Yujie</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yujie</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
